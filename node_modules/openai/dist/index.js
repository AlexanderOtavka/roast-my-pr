(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "form-data", "node-fetch"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require("tslib");
    const form_data_1 = tslib_1.__importDefault(require("form-data"));
    const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
    const baseUrl = 'https://api.openai.com';
    const defaultVersion = 'v1';
    class OpenAI {
        url;
        headers;
        constructor(apiKey, organizationId, version = defaultVersion) {
            this.headers = {
                'authorization': `Bearer ${apiKey}`,
                'content-type': 'application/json',
            };
            if (organizationId) {
                this.headers['openai-organization'] = organizationId;
            }
            this.url = `${baseUrl}/${version}`;
        }
        getEngines() {
            return this.request('/engines', 'GET').then((r) => r.data);
        }
        getEngine(engine) {
            return this.request(`/engines/${engine}`, 'GET');
        }
        complete(engine, options) {
            return this.request(`/engines/${engine}/completions`, 'POST', options);
        }
        search(engine, options) {
            return this.request(`/engines/${engine}/search`, 'POST', options).then((r) => r.data);
        }
        classify(options) {
            return this.request('/classifications', 'POST', options);
        }
        answer(options) {
            return this.request('/answers', 'POST', options);
        }
        getFiles() {
            return this.request('/files', 'GET').then((r) => r.data);
        }
        uploadFile(file, jsonlines, purpose) {
            const data = new form_data_1.default();
            let fileJsonlines;
            if (Array.isArray(jsonlines)) {
                if (typeof jsonlines[0] === 'object') {
                    jsonlines = jsonlines.map((j) => JSON.stringify(j));
                }
                fileJsonlines = jsonlines.join('\n');
            }
            else {
                fileJsonlines = jsonlines;
            }
            data.append('file', fileJsonlines, file);
            data.append('purpose', purpose);
            return this.request('/files', 'POST', data);
        }
        getFile(fileId) {
            return this.request(`/files/${fileId}`, 'GET');
        }
        deleteFile(fileId) {
            return this.request(`/files/${fileId}`, 'DELETE');
        }
        finetune(options) {
            return this.request(`/fine-tunes`, 'POST', options);
        }
        getFinetunes() {
            return this.request('/fine-tunes', 'GET').then((r) => r.data);
        }
        getFinetune(finetuneId) {
            return this.request(`/fine-tunes/${finetuneId}`, 'GET');
        }
        cancelFinetune(finetuneId) {
            return this.request(`/fine-tunes/${finetuneId}/cancel`, 'POST');
        }
        getFinetuneEvents(finetuneId) {
            return this.request(`/fine-tunes/${finetuneId}/events`, 'GET').then((r) => r.data);
        }
        async request(path, method, body) {
            let headers = this.headers;
            if (body instanceof form_data_1.default) {
                delete headers['content-type'];
                headers = body.getHeaders(headers);
            }
            else if (!['string', 'undefined'].includes(typeof body)) {
                body = JSON.stringify(body);
            }
            const response = await node_fetch_1.default(this.url + path, {
                headers,
                method,
                body: body,
            });
            if (!response.ok) {
                let errorBody;
                try {
                    errorBody = await response.text();
                }
                catch {
                    errorBody = 'Failed to get body as text';
                }
                throw new Error(`OpenAI did not return ok: ${response.status} ~ Error body: ${errorBody}`);
            }
            return response.json();
        }
    }
    exports.default = OpenAI;
});
